#!/bin/sh
ppq_install()
{
#!/bin/sh

dest=

while [ $# -ne 0 ]
do
  case "$1" in
    -d | --dest) shift;dest="$1";;
    *) echo "error: Invalid argument '$1'" 1>&2;exit 1;;
  esac
  shift
done

ppq_build && DESTDIR="$dest" cmake --install build
}
ppq_run()
{
#!/bin/sh

config__package__name=
config__package__bin=
{
  ppq_parse package__bin
  [ -z "$config__package__name" ] && ppq_parse package__name
} < package.ppq

ppq_build --target "${config__package__name}-bin" && build/"$config__package__bin"
}
ppq_parse()
{
#!/bin/sh

search="config__$1"

current_depth="${current_depth:-0}"
names0=config
current_name="${current_name:-$names0}"

start_new_obj() {
  [ "$current_name" = "$search" ] && return 1
  current_depth=$(expr "  $1" : '[ \t]*')
  raw_name=$(expr "$1" : '.*\[\(.*\)\]')
  name=$(echo "$raw_name" | tr -c '[:alnum:]_\n' '_')
  eval "names$current_depth=\"\${names$(("$current_depth" - 2))}__$name\""
  current_name=$(eval echo "\"\$names$current_depth\"")
}

append_field() {
  name=$(expr "$1" : '\s*\([^ ]*\)\s*=' | tr -c '[:alnum:]_\n' '_')
  value=$(expr "$1" : '.*=\s*\(.*\)\s*')
  #echo "${current_name}__$name='$value'"
  eval "${current_name}__$name='$value'"
  [ "${current_name}__$name" = "$search" ] && return 1 || return 0
}

while IFS="" read -r line
do
  case "$(expr "$line" : '\s*\(.*\)')" in
    ''|\#*);;
    \[*\]) start_new_obj "$line" || break;;
    *) append_field "$line" || break;;
  esac
done
}
ppq_test()
{
#!/bin/sh

ppq_build --target test
}
ppq_help()
{
#!/bin/sh
:
}
ppq_init()
{
#!/bin/sh

force=

while :
do
  case "$1" in
    -f | --force) force=1;;
    -*) "error: Unkown option '$1'";;
    *) break;;
  esac
  shift
done

{
  [ -z "$force" ] && [ -f CMakeLists.txt ] &&\
    echo "error: File 'CMakeLists.txt' already exists" && exit 1
} 1>&2

projname=${1:-$(printf "project name:\n-> " 1>&2; read -r tmp; echo "$tmp")}

echo "Creating project '$projname'..." 1>&2

{
  echo "[meta]"
  echo "config_version = 1"
  echo ""
  echo "[package]"
  echo "name = $projname"
  echo "version = 0.1.0"
  echo "bin = $projname"
  echo "lib = $projname"
  echo "test_framework = cassert"
} > package.ppq

{
  echo "cmake_minimum_required(VERSION 3.1)"
  echo ""
  echo "project($projname VERSION 0.1.0 LANGUAGES CXX)"
  echo ""
  echo "add_library($projname)"
  echo "target_include_directories($projname PUBLIC"
  echo "    \$<BUILD_INTERFACE:\${CMAKE_CURRENT_SOURCE_DIR}/include>"
  echo "    \$<INSTALL_INTERFACE:include>)"
  echo "target_sources($projname PRIVATE"
  echo "    src/$projname/lib.cpp)"
  echo ""
  echo "add_executable(${projname}-bin src/main.cpp)"
  echo "set_target_properties(${projname}-bin"
  echo "    PROPERTIES OUTPUT_NAME $projname)"
  echo "target_link_libraries(${projname}-bin"
  echo "    $projname)"
  echo ""
  echo "install(TARGETS $projname ${projname}-bin"
  echo "    EXPORT ${projname}-config"
  echo "    ARCHIVE DESTINATION lib"
  echo "    LIBRARY DESTINATION lib"
  echo "    RUNTIME DESTINATION bin)"
  echo ""
  echo "install(EXPORT ${projname}-config"
  echo "    NAMESPACE ${projname}"
  echo "    DESTINATION lib/cmake/$projname)"
  echo ""
  echo "include(CMakePackageConfigHelpers)"
  echo ""
  echo "write_basic_package_version_file("
  echo "    \${CMAKE_CURRENT_BINARY_DIR}/${projname}-config-version.cmake"
  echo "    COMPATIBILITY SameMajorVersion)"
  echo ""
  echo "install(FILES \${CMAKE_CURRENT_BINARY_DIR}/${projname}-config-version.cmake"
  echo "    DESTINATION lib/cmake/$projname)"
  echo "install(DIRECTORY \${CMAKE_CURRENT_SOURCE_DIR}/include/"
  echo "    DESTINATION include)"
  echo ""
  echo "if(CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)"
  echo "    include(CTest)"
  echo "    if(BUILD_TESTING)"
  echo "        add_subdirectory(test)"
  echo "    endif()"
  echo "endif()"
} > CMakeLists.txt

mkdir -p test
mkdir -p src/"$projname"
mkdir -p include/"$projname"

{
  echo "#include <$projname/lib.hpp>"
  echo ""
  echo "int main() {"
  echo "  $projname::hello();"
  echo "}"
} > src/main.cpp

{
  echo "#ifndef $(echo "$projname" | tr '[:lower:]' '[:upper:]')_LIB"
  echo "#define $(echo "$projname" | tr '[:lower:]' '[:upper:]')_LIB"
  echo ""
  echo "namespace $projname {"
  echo "auto hello() -> void;"
  echo "}"
  echo "#endif"
} > include/"$projname"/lib.hpp

{
  echo "#include <$projname/lib.hpp>"
  echo "#include <cstdio>"
  echo ""
  echo "namespace $projname {"
  echo "auto hello() -> void {"
  echo "  std::puts(\"Hello, $projname.\");"
  echo "}"
  echo "}"
} > src/"$projname"/lib.cpp

{
  echo "#include <cassert>"
  echo ""
  echo "int main() {"
  echo "  static_assert(1 + 1 == 2);"
  echo "  assert(1 + 1 == 2);"
  echo "}"
} > test/test.cpp

{
  echo "set(${projname}_unit_tests_count 0)"
  echo ""
  echo "function(add_unit_test source_file)"
  echo "  math(EXPR tmp \"\${${projname}_unit_tests_count} + 1\")"
  echo "  set(${projname}_unit_tests_count \${tmp} PARENT_SCOPE)"
  echo "  set(test_binary \"${projname}_unit_test\${${projname}_unit_tests_count}\")"
  echo ""
  echo "  add_executable(\${test_binary} EXCLUDE_FROM_ALL \"\${source_file}\")"
  echo "  add_test([build]\${source_file}"
  echo "    \${CMAKE_COMMAND} --build \${CMAKE_BINARY_DIR} --target \${test_binary})"
  echo ""
  echo "  add_test(NAME \${source_file} COMMAND \${test_binary})"
  echo "  set_tests_properties(\${source_file} PROPERTIES DEPENDS [build]\${test_binary})"
  echo "endfunction()"
  echo ""
  for src in $(find test -type f -name '*.cpp' | sed -e 's/^test\///')
  do
    echo "add_unit_test($src)"
  done
} > test/CMakeLists.txt

mkdir -p build && cmake -S . -B build
}
ppq_build()
{
#!/bin/sh

target=all

while [ $# -ne 0 ]
do
  case "$1" in
    -t | --target) shift;target="$1";;
    *) echo "error: Invalid argument '$1'" 1>&2;exit 1;;
  esac
  shift
done

mkdir -p build && cmake -S . -B build && cmake --build build --target "$target"
}
#!/bin/sh

subcmd=${1:-help}
[ $# -ne 0 ] && shift
ppq_"$subcmd" "$@"
